/**
 * Canvas Realtime Database Service
 * 
 * Handles canvas objects and cursors using Firebase Realtime Database
 * for optimal real-time performance with high-frequency updates.
 * 
 * Architecture:
 * - Canvas objects: High-frequency updates during drag/resize
 * - Cursors: Ephemeral, real-time position tracking
 */

import {
  ref,
  set,
  get,
  update,
  remove,
  onValue,
  off,
  push,
  runTransaction,
  onDisconnect,
} from 'firebase/database';
import type { Unsubscribe } from 'firebase/database';
import { rtdb } from '../config/firebase';
import type { CanvasObject } from '../types/canvas';

// Database paths
const CANVAS_PATH = 'canvas/global';
const OBJECTS_PATH = `${CANVAS_PATH}/objects`;
const CURSORS_PATH = `${CANVAS_PATH}/cursors`;

// Type definitions
interface CanvasObjectInput extends Omit<CanvasObject, 'id'> {
  // For creating objects, ID will be generated by push()
}

type CanvasObjectUpdate = Partial<{
  x: number;
  y: number;
  width: number;
  height: number;
  radius: number;
  text: string;
  fontSize: number;
  fontFamily: string;
  fontWeight: 'normal' | 'bold';
  fontStyle: 'normal' | 'italic';
  textAlign: 'left' | 'center' | 'right';
  textDecoration: string;
  textColor: string;
  backgroundColor: string;
  color: string;
  rotation: number;
  modifiedBy: string;
  lockedBy: string | null;
  lockedAt: number | null;
  version: number;
}>;

export interface CursorData {
  x: number;
  y: number;
  name: string;
  color: string;
  lastSeen: number;
}

/**
 * Initialize canvas in Realtime Database
 * Note: This just checks connectivity. The actual objects and cursors paths
 * will be created automatically when data is written.
 */
export const initializeCanvas = async (): Promise<void> => {
  try {
    // Just verify we can read from the objects path
    const objectsRef = ref(rtdb, OBJECTS_PATH);
    await get(objectsRef);
    console.log('Canvas RTDB connection verified');
  } catch (error) {
    // Log but don't fail - the canvas will still work
    console.warn('Canvas connection check failed (may need authentication):', error);
  }
};

/**
 * Generate a new RTDB key without creating the object yet
 */
export const generateObjectId = (): string => {
  const objectsRef = ref(rtdb, OBJECTS_PATH);
  return push(objectsRef).key!;
};

/**
 * Create a new canvas object with a specific ID
 */
export const createObject = async (objectId: string, objectData: CanvasObjectInput): Promise<string> => {
  try {
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    
    await set(objectRef, {
      ...objectData,
      createdAt: Date.now(),
      modifiedAt: Date.now(),
    });

    return objectId;
  } catch (error) {
    console.error('Error creating object:', error);
    throw error;
  }
};

/**
 * Update an existing canvas object
 */
export const updateObject = async (
  objectId: string,
  updates: CanvasObjectUpdate
): Promise<void> => {
  try {
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    await update(objectRef, {
      ...updates,
      modifiedAt: Date.now(),
    });
  } catch (error) {
    console.error('Error updating object:', error);
    throw error;
  }
};

/**
 * Delete a canvas object
 */
export const deleteObject = async (objectId: string): Promise<void> => {
  try {
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    await remove(objectRef);
  } catch (error) {
    console.error('Error deleting object:', error);
    throw error;
  }
};

/**
 * Batch update multiple objects (for multi-select operations)
 */
export const batchUpdateObjects = async (
  updates: Array<{ id: string; data: CanvasObjectUpdate }>
): Promise<void> => {
  try {
    const updateData: Record<string, any> = {};
    const timestamp = Date.now();

    updates.forEach(({ id, data }) => {
      Object.keys(data).forEach((key) => {
        updateData[`${OBJECTS_PATH}/${id}/${key}`] = data[key as keyof CanvasObjectUpdate];
      });
      updateData[`${OBJECTS_PATH}/${id}/modifiedAt`] = timestamp;
    });

    const dbRef = ref(rtdb);
    await update(dbRef, updateData);
  } catch (error) {
    console.error('Error batch updating objects:', error);
    throw error;
  }
};

/**
 * Subscribe to all canvas objects (real-time)
 */
export const subscribeToObjects = (
  callback: (objects: CanvasObject[]) => void
): Unsubscribe => {
  const objectsRef = ref(rtdb, OBJECTS_PATH);

  const unsubscribe = onValue(
    objectsRef,
    (snapshot) => {
      const data = snapshot.val();
      
      if (!data) {
        callback([]);
        return;
      }

      const objects: CanvasObject[] = Object.keys(data).map((id) => {
        const obj = data[id];
        // Ensure the ID from the key takes precedence over any ID in the data
        // IMPORTANT: Create a NEW object to ensure React detects the change
        return {
          ...obj,
          id,  // Override with key to ensure consistency
          // Normalize null/undefined to null for consistent comparison
          lockedBy: obj.lockedBy || null,
          lockedAt: obj.lockedAt || null,
        };
      });

      callback(objects);
    },
    (error) => {
      console.error('Error subscribing to objects:', error);
    }
  );

  return () => {
    off(objectsRef, 'value', unsubscribe);
  };
};

/**
 * Get a single object (one-time fetch)
 */
export const getObject = async (objectId: string): Promise<CanvasObject | null> => {
  try {
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    const snapshot = await get(objectRef);

    if (!snapshot.exists()) {
      return null;
    }

    return {
      id: objectId,
      ...snapshot.val(),
    };
  } catch (error) {
    console.error('Error getting object:', error);
    throw error;
  }
};

/**
 * Acquire lock on an object (using transaction for atomic operation)
 * Checks if the lock holder is still online/active before allowing takeover
 */
export const acquireObjectLock = async (
  objectId: string,
  userId: string
): Promise<boolean> => {
  try {
    // First, check if the object is locked by someone else
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    const snapshot = await get(objectRef);
    
    if (snapshot.exists()) {
      const objectData = snapshot.val();
      
      // If locked by someone else, check if that user is still online
      if (objectData.lockedBy && objectData.lockedBy !== userId) {
        // Check if the lock holder has an active cursor (meaning they're online)
        const cursorRef = ref(rtdb, `${CURSORS_PATH}/${objectData.lockedBy}`);
        const cursorSnapshot = await get(cursorRef);
        
        if (cursorSnapshot.exists()) {
          const cursorData = cursorSnapshot.val();
          const cursorAge = Date.now() - (cursorData.lastSeen || 0);
          const CURSOR_TIMEOUT = 10000; // 10 seconds - if cursor is older, user is offline
          
          if (cursorAge < CURSOR_TIMEOUT) {
            // console.log(`[RTDB Lock] Object ${objectId} locked by ONLINE user ${objectData.lockedBy}`);
            return false; // User is online, lock is valid
          } else {
            console.log(`[RTDB Lock] Lock holder appears offline (cursor age: ${cursorAge}ms), allowing takeover`);
          }
        } else {
          console.log(`[RTDB Lock] Lock holder has no cursor data, allowing takeover`);
        }
      }
    }
    
    // Now use transaction to atomically acquire the lock
    const lockRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}/lockedBy`);
    
    const result = await runTransaction(lockRef, (currentValue) => {
      // If unlocked or re-acquiring own lock
      if (currentValue === null || currentValue === userId) {
        return userId;
      }
      // Lock is held by someone else - online check was done above
      // console.log(`[RTDB Lock] Transaction abort: Object ${objectId} locked by ${currentValue}`);
      return undefined; // Abort transaction
    });

    if (result.committed) {
      // console.log(`[RTDB Lock] Successfully acquired lock on ${objectId} for user ${userId}`);
      
      // Update lockedAt timestamp
      await update(objectRef, {
        lockedAt: Date.now(),
      });
      
      // Set up automatic lock cleanup on disconnect
      onDisconnect(objectRef).update({
        lockedBy: null,
        lockedAt: null,
      });
      
      return true;
    }

    // console.log(`[RTDB Lock] Failed to acquire lock on ${objectId}, transaction not committed`);
    return false;
  } catch (error) {
    console.error('Error acquiring object lock:', error);
    return false;
  }
};

/**
 * Release lock on an object
 */
export const releaseObjectLock = async (objectId: string): Promise<void> => {
  try {
    const objectRef = ref(rtdb, `${OBJECTS_PATH}/${objectId}`);
    
    // Cancel the onDisconnect handler since we're explicitly releasing the lock
    await onDisconnect(objectRef).cancel();
    
    // Release the lock
    await update(objectRef, {
      lockedBy: null,
      lockedAt: null,
    });
  } catch (error) {
    console.error('Error releasing object lock:', error);
    throw error;
  }
};

// ==================== CURSOR OPERATIONS ====================

/**
 * Update cursor position for a user
 */
export const updateCursor = async (
  userId: string,
  x: number,
  y: number,
  name: string,
  color: string
): Promise<void> => {
  try {
    const cursorRef = ref(rtdb, `${CURSORS_PATH}/${userId}`);
    await set(cursorRef, {
      x,
      y,
      name,
      color,
      lastSeen: Date.now(),
    });
  } catch (error) {
    console.error('Error updating cursor:', error);
    throw error;
  }
};

/**
 * Remove cursor for a user (on disconnect)
 */
export const removeCursor = async (userId: string): Promise<void> => {
  try {
    const cursorRef = ref(rtdb, `${CURSORS_PATH}/${userId}`);
    await remove(cursorRef);
  } catch (error) {
    console.error('Error removing cursor:', error);
    throw error;
  }
};

/**
 * Subscribe to all cursors (real-time)
 */
export const subscribeToCursors = (
  callback: (cursors: Map<string, CursorData>) => void
): Unsubscribe => {
  const cursorsRef = ref(rtdb, CURSORS_PATH);

  const unsubscribe = onValue(
    cursorsRef,
    (snapshot) => {
      const data = snapshot.val();
      const cursors = new Map<string, CursorData>();

      if (data) {
        Object.keys(data).forEach((userId) => {
          const cursorData = data[userId];
          
          // Filter out stale cursors (>30s old)
          const now = Date.now();
          if (now - cursorData.lastSeen < 30000) {
            cursors.set(userId, cursorData);
          }
        });
      }

      callback(cursors);
    },
    (error) => {
      console.error('Error subscribing to cursors:', error);
    }
  );

  return () => {
    off(cursorsRef, 'value', unsubscribe);
  };
};

/**
 * Clean up stale cursors (call periodically)
 */
export const cleanupStaleCursors = async (): Promise<void> => {
  try {
    const cursorsRef = ref(rtdb, CURSORS_PATH);
    const snapshot = await get(cursorsRef);

    if (!snapshot.exists()) {
      return;
    }

    const data = snapshot.val();
    const now = Date.now();
    const staleThreshold = 30000; // 30 seconds

    const updates: Record<string, null> = {};

    Object.keys(data).forEach((userId) => {
      const cursor = data[userId];
      if (now - cursor.lastSeen > staleThreshold) {
        updates[`${CURSORS_PATH}/${userId}`] = null;
      }
    });

    if (Object.keys(updates).length > 0) {
      const dbRef = ref(rtdb);
      await update(dbRef, updates);
    }
  } catch (error) {
    console.error('Error cleaning up stale cursors:', error);
  }
};

// ==================== UTILITY OPERATIONS ====================

/**
 * Delete all objects (for testing/reset purposes)
 * Deletes each object individually to respect security rules
 */
export const deleteAllObjects = async (): Promise<number> => {
  try {
    const objectsRef = ref(rtdb, OBJECTS_PATH);
    const snapshot = await get(objectsRef);

    if (!snapshot.exists()) {
      return 0;
    }

    const data = snapshot.val();
    const objectIds = Object.keys(data);
    const count = objectIds.length;

    // Delete each object individually (respects security rules)
    const deletePromises = objectIds.map(objectId => 
      remove(ref(rtdb, `${OBJECTS_PATH}/${objectId}`))
    );
    
    await Promise.all(deletePromises);
    return count;
  } catch (error) {
    console.error('Error deleting all objects:', error);
    throw error;
  }
};

/**
 * Release expired locks (locks older than 30 seconds)
 * Note: Only clears current user's own locks. Other expired locks are handled during lock acquisition.
 */
export const releaseExpiredLocks = async (currentUserId: string): Promise<void> => {
  try {
    const objectsRef = ref(rtdb, OBJECTS_PATH);
    const snapshot = await get(objectsRef);

    if (!snapshot.exists()) {
      return;
    }

    const data = snapshot.val();
    const now = Date.now();
    const lockTimeout = 30000; // 30 seconds
    const updates: Record<string, null> = {};

    // Only release locks held by the current user
    Object.keys(data).forEach((objectId) => {
      const obj = data[objectId];
      if (
        obj.lockedBy &&
        obj.lockedBy === currentUserId && // Changed: only clear own locks
        obj.lockedAt &&
        now - obj.lockedAt > lockTimeout
      ) {
        updates[`${OBJECTS_PATH}/${objectId}/lockedBy`] = null;
        updates[`${OBJECTS_PATH}/${objectId}/lockedAt`] = null;
      }
    });

    if (Object.keys(updates).length > 0) {
      const dbRef = ref(rtdb);
      await update(dbRef, updates);
    }
  } catch (error) {
    // Fail silently - lock cleanup is a non-critical optimization
    console.debug('Lock cleanup skipped:', error);
  }
};

